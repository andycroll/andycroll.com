---
title: "Know what your scopes are doing: where.first vs find_by"
description: "Attack of the abstracted SQL"
layout: article
category: ruby
image:
  base: "2022/where-first-vs-find-by-know-what-your-scopes-are-doing"
  alt: "Wooden file card drawers"
  credit: "Jan Antonin Kolar"
  source: "https://unsplash.com/photos/lRoX0shwjUQ"

---

There are numerous benefits to using an Object-Relational Mapper (ORM) such as Active Record, to generate your SQL. You gain from clear repeatable abstractions, saving time and gaining readability.

Unfortunately the very abstractions that make an ORM useful can also have unintended consequences.

It is very easy to introduce performance problems as the _actual_ SQL that runs on your database server is generated by the framework.

We recently came across an issue at CoverageBook that highlighted this very issue.


## Instead of:

...using a `where` condition then `first`.

```ruby
User.where(email: "andy@goodscary.com").first
```


## Use:

...`find_by`

```ruby
User.find_by(email: "andy@goodscary.com")
User.find_by_email("andy@goodscary.com")
```


## Why?

This is one of those cases where the ORM (and the tooling around it) get in the way and introduce unforseen performance issues.

The `.where` scope has an implicit `ORDER` scope on the primary key that isn't obvious at first glance.

```ruby
User.where(email: "andy@goodscary.com")
# SELECT "users".*
# FROM "users"
# WHERE "users"."email" = "andy@goodscary.com"

User.where(email: "andy@goodscary.com").first
# SELECT "users".*
# FROM "users"
# WHERE "users"."email" = "andy@goodscary.com"
# ORDER BY "users"."id" ASC
# LIMIT 1

User.find_by(email: "andy@goodscary.com")
# SELECT "users".*
# FROM "users"
# WHERE "users"."email" = "andy@goodscary.com"
# LIMIT 1
```

Indexes on our database didn't help us as in our (specific, more complex) case, as the field we were querying on was indexed, but then we were inadvertantly doing a non-indexed scan to establish the order.

We were writing many thousands of rows per second and even with a monsterously powerful database we were seeing issues because the entire table was being sorted to pick only one record.

It's also hard to debug the generated SQL in the console as only the plain `.where` scope (that returns an un-executed, chainable `Relation`) can have the `.to_sql` method called on it. As soon as you use `.find_by` or `.first` the query executes and you have to use logging to work out the exact SQL that is being generated.


## Why not?

In small tables, under light load, this would not be important. The specific example I've drawn above would be unlikely to cause any real issues, however knowing the exact SQL Active Record is generating from methods that might _seem_ the same can be _very_ important.

