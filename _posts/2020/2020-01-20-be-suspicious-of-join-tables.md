---
title: "Be Suspicious of Join Tables"
description: "They're probably hiding a concept you haven’t named yet"
layout: article
category: ruby
image:
  base: '2020/be-suspicious-of-join-tables'
  alt: Welding
  credit:  Max LaRochelle
  source: "https://unsplash.com/photos/QzP1GcDOSC8"

---

We often have to represent many-to-many relationships between models in our applications. Rails provides a method in the migrations to generate a table in your database to support this, you can see the documentation in the [Rails guide for ActiveRecord migrations](https://guides.rubyonrails.org/active_record_migrations.html#creating-a-join-table).

However these “simple” join tables often obscure a useful concept in your application that could easily be a model.


## Instead of...

...using a join table

#### Migration

```ruby
create_join_table :user, :organisation
```

#### `app/models/user.rb`

```ruby
class User < ApplicationRecord
  has_and_belongs_to_many :organisations
end
```

#### `app/models/organisation.rb`

```ruby
class Organisation < ApplicationRecord
  has_and_belongs_to_many :users
end
```

## Use

...a real model, by naming the concept that the join table is hiding

#### Migration

```ruby
create_table :memberships do |t|
  t.references :user
  t.references :organisation
end
```

#### `app/models/membership.rb`

```ruby
class Membership < ApplicationRecord
  belongs_to :user
  belongs_to :organisation
end
```

#### `app/models/user.rb`

```ruby
class User < ApplicationRecord
  has_many :memberships
  has_many :organisations, through: :memberships
end
```

#### `app/models/organisation.rb`

```ruby
class Organisation < ApplicationRecord
  has_many :memberships
  has_many :users, through: :memberships
end
```


## Why?

Almost without fail, whenever a join model sits for any length of time in an application it begins to acquire behaviour. It’s nearly always worth working out and having a first pass at naming the concept that the join model represents.

With a simple join model you may accidentally attach functionality to one of the joined models, `User` and `Organisation` in this example, making later refactoring harder.


## Why not?

There’s extra manual work to be done when you can’t simply use [the methods automatically generated by `has_and_belongs_to_many`](https://api.rubyonrails.org/v5.2.4/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_and_belongs_to_many) but you gain the extra flexibility and clarity of the new concept.

You _can_ always build a quick join model to get going and explore the domain of your application. But be ready to change the table into a ‘proper model’ when you start to discover attributes or logic that feels like it belongs to the join.